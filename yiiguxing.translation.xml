<application>
  <component name="AppStorage">
    <histories>
      <item value="Transcoder" />
      <item value="GIF Disposal Method meaning clear canvas to frame before last. * &lt;p&gt;&lt;b&gt;GIF89a&lt;/b&gt;: &lt;i&gt;Restore to previous. * The decoder is required to restore the area overwritten by the graphic * with what was there prior to rendering the graphic.&lt;/i&gt;&lt;/p&gt;" />
      <item value="previous" />
      <item value="百分比" />
      <item value="Quality" />
      <item value="format" />
      <item value="consume" />
      <item value="Responsive" />
      <item value="Tries to intelligently choose a strategy based on the data source of the {@link * com.bumptech.glide.load.data.DataFetcher} and the {@link * com.bumptech.glide.load.EncodeStrategy} of the {@link com.bumptech.glide.load.ResourceEncoder} * (if an {@link com.bumptech.glide.load.ResourceEncoder} is available)" />
      <item value="Writes resources to disk after they've been decoded" />
      <item value="Writes retrieved data directly to the disk cache before it's decoded" />
      <item value="Saves no data to cache." />
      <item value="Caches remote data with both {@link #DATA} and {@link #RESOURCE}, and local data with {@link * #RESOURCE} only." />
      <item value="original" />
      <item value="Called getWidth() on a recycle()'d bitmap! This is undefined behavior!" />
      <item value="limit" />
      <item value="Gets the Object mapped from the specified key, or &lt;code&gt;null&lt;/code&gt; * if no such mapping has been made." />
      <item value="is Recycled" />
      <item value="Cannot pool recycled bitmap" />
      <item value="remaining" />
      <item value="More than one file was found with OS independent path 'lib/x86/libTPGDecoder.so'. If you are using jniLibs and CMake IMPORTED targets," />
      <item value="Reads 16k chunks from the native buffer for processing, to greatly reduce JNI overhead." />
      <item value="Temporary buffer for block reading." />
      <item value="Reads next variable length block from input. * * @return number of bytes stored in &quot;buffer&quot;." />
      <item value="Reads the next chunk for the intermediate work buffer." />
      <item value="LZW decoder working arrays." />
      <item value="Temporary buffer for block reading. * Reads 16k chunks from the native buffer for processing, to greatly reduce JNI overhead." />
      <item value="Raw data read working array" />
      <item value="Modifies this buffer's byte order." />
      <item value="* Constant denoting little-endian byte order. In this order, the bytes of * a multibyte value are ordered from least significant to most * significant." />
      <item value="interface using file path as input" />
      <item value="Clear missing pixels." />
      <item value="Allocate new pixel array." />
      <item value="First frame was drawed before optimized, so skip!" />
      <item value="Copy pixels into previous image" />
      <item value="We should check and see if all individual pixels are replaced. If they are, the // first frame isn't actually transparent. For now, it's simpler and safer to assume // drawing a transparent background means the GIF contains transparency." />
      <item value="Transparent" />
      <item value="GIF Disposal Method meaning clear canvas to frame before last." />
      <item value="GIF Disposal Method meaning clear canvas to background color." />
      <item value="GIF Disposal Method meaning take no action." />
      <item value="Disposal Method." />
      <item value="is now in focus and seems to be in full-screen mode" />
      <item value="Decode pixels for this frame into the global pixels[] scratch." />
      <item value="Creates new frame image from current data (and previous frames as specified by their * disposition codes)." />
      <item value="Can't call reconfigure() on a recycled bitmap" />
      <item value="Identical to {@link #get(int, int, android.graphics.Bitmap.Config)} except that any returned * {@link android.graphics.Bitmap} may &lt;em&gt;not&lt;/em&gt; have been erased and may contain random data. * * &lt;p&gt;If no Bitmap with the requested attributes is present in the pool, a new one will be * allocated. &lt;/p&gt; * * &lt;p&gt; Although this method is slightly more efficient than {@link #get(int, int, * android.graphics.Bitmap.Config)} it should be used with caution and only when the caller is * sure that they are going to erase the {@link android.graphics.Bitmap} entirely before writing * new data to it. &lt;/p&gt; * * @param width The width in pixels of the desired {@link android.graphics.Bitmap}. * @param height The height in pixels of the desired {@link android.graphics.Bitmap}. * @param config The {@link android.graphics.Bitmap.Config} of the desired {@link * android.graphics.Bitmap}. * @return A {@link android.graphics.Bitmap} with exactly the given width, height, and config * potentially containing random image data or null if no such {@link android.graphics.Bitmap} * could be obtained from the pool. * @see #get(int, int, android.graphics.Bitmap.Config)" />
      <item value="Dirty" />
      <item value="get Dirty" />
      <item value="Cannot obtain size for recycled Bitmap" />
      <item value="Interface for an array pool that pools arrays of different types." />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="412" />
        <entry key="ENGLISH" value="413" />
        <entry key="ESTONIAN" value="1" />
        <entry key="ICELANDIC" value="1" />
        <entry key="RUSSIAN" value="1" />
        <entry key="FRENCH" value="6" />
        <entry key="LATIN" value="1" />
        <entry key="LITHUANIAN" value="1" />
        <entry key="PORTUGUESE" value="2" />
        <entry key="SWEDISH" value="1" />
        <entry key="ITALIAN" value="2" />
        <entry key="INDONESIAN" value="1" />
        <entry key="VIETNAMESE" value="1" />
      </map>
    </option>
  </component>
</application>